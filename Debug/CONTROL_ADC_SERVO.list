
CONTROL_ADC_SERVO.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00000450  08000198  08000198  00010198  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  080005e8  080005f0  000105f0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .init_array   00000004  080005e8  080005e8  000105e8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  080005ec  080005ec  000105ec  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000000  20000000  20000000  000105f0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000024  20000000  080005f0  00020000  2**2
                  ALLOC
  7 ._user_heap_stack 00000400  20000024  080005f0  00020024  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  000105f0  2**0
                  CONTENTS, READONLY
  9 .debug_info   000011af  00000000  00000000  00010620  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000377  00000000  00000000  000117cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 000000d8  00000000  00000000  00011b48  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b0  00000000  00000000  00011c20  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000052e  00000000  00000000  00011cd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00000950  00000000  00000000  000121fe  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .comment      0000007c  00000000  00000000  00012b4e  2**0
                  CONTENTS, READONLY
 16 .debug_frame  00000274  00000000  00000000  00012bcc  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .stabstr      0000003f  00000000  00000000  00012e40  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	; (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	; (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	; (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000000 	.word	0x20000000
 80001b4:	00000000 	.word	0x00000000
 80001b8:	080005d0 	.word	0x080005d0

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	; (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	; (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	; (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000004 	.word	0x20000004
 80001d4:	080005d0 	.word	0x080005d0

080001d8 <main>:




int main(void)
{
 80001d8:	b580      	push	{r7, lr}
 80001da:	b084      	sub	sp, #16
 80001dc:	af02      	add	r7, sp, #8

	ADC_Init ();
 80001de:	f000 f837 	bl	8000250 <ADC_Init>
	ADC_Enable ();
 80001e2:	f000 f87f 	bl	80002e4 <ADC_Enable>
	DMA_Init ();
 80001e6:	f000 f8c5 	bl	8000374 <DMA_Init>
	DMA_Config ();
 80001ea:	f000 f895 	bl	8000318 <DMA_Config>
	TIM2_Init();
 80001ee:	f000 f90d 	bl	800040c <TIM2_Init>

	ADC_Start ();
 80001f2:	f000 f8ad 	bl	8000350 <ADC_Start>

	//ADC_WaitForConv();
	//ADC_VAL = ADC_GetVal();

	// Map The ADC Result To Servo Pulse Width
	angle = mapping(ADC_VAL, 0, 4096, 25, 125);
 80001f6:	4b0c      	ldr	r3, [pc, #48]	; (8000228 <main+0x50>)
 80001f8:	881b      	ldrh	r3, [r3, #0]
 80001fa:	b29b      	uxth	r3, r3
 80001fc:	4618      	mov	r0, r3
 80001fe:	237d      	movs	r3, #125	; 0x7d
 8000200:	9300      	str	r3, [sp, #0]
 8000202:	2319      	movs	r3, #25
 8000204:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000208:	2100      	movs	r1, #0
 800020a:	f000 f8e3 	bl	80003d4 <mapping>
 800020e:	4603      	mov	r3, r0
 8000210:	b29a      	uxth	r2, r3
 8000212:	4b06      	ldr	r3, [pc, #24]	; (800022c <main+0x54>)
 8000214:	801a      	strh	r2, [r3, #0]
	// Set PWM duty cycle
	TIM2 -> CCR1 = angle;
 8000216:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800021a:	4a04      	ldr	r2, [pc, #16]	; (800022c <main+0x54>)
 800021c:	8812      	ldrh	r2, [r2, #0]
 800021e:	b292      	uxth	r2, r2
 8000220:	635a      	str	r2, [r3, #52]	; 0x34
	//TIM2 -> CCR1 = 100; //  duty cycle is 2 ms  according to Real servo position +45 Deg
	TIM2 -> CCR1 = 125; // duty cycle is 2.5 ms, according to Real servo position +90 Deg
	Delay_ms (2000);
	*/

	int breakPtr = 0;
 8000222:	2300      	movs	r3, #0
 8000224:	607b      	str	r3, [r7, #4]
	{
 8000226:	e7e6      	b.n	80001f6 <main+0x1e>
 8000228:	2000001c 	.word	0x2000001c
 800022c:	2000001e 	.word	0x2000001e

08000230 <SysTick_Handler>:
	} // end while
} // end main

/* Interrupts */
void SysTick_Handler(void)
{
 8000230:	b480      	push	{r7}
 8000232:	af00      	add	r7, sp, #0
msTicks++;
 8000234:	4b05      	ldr	r3, [pc, #20]	; (800024c <SysTick_Handler+0x1c>)
 8000236:	881b      	ldrh	r3, [r3, #0]
 8000238:	3301      	adds	r3, #1
 800023a:	b29a      	uxth	r2, r3
 800023c:	4b03      	ldr	r3, [pc, #12]	; (800024c <SysTick_Handler+0x1c>)
 800023e:	801a      	strh	r2, [r3, #0]
}
 8000240:	bf00      	nop
 8000242:	46bd      	mov	sp, r7
 8000244:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000248:	4770      	bx	lr
 800024a:	bf00      	nop
 800024c:	20000020 	.word	0x20000020

08000250 <ADC_Init>:


/* Private functions */

void ADC_Init (void)
{
 8000250:	b480      	push	{r7}
 8000252:	af00      	add	r7, sp, #0
	5. Set the Regular channel sequence length in ADC_SQR1 and set Channel 1 in ADC_SQR3
	7. Set the Respective GPIO PINs in the Analog Mode
	************************************************/

//1. Enable ADC and GPIO clock
	RCC->APB2ENR |= (1<<8);  // enable ADC1 clock
 8000254:	4a20      	ldr	r2, [pc, #128]	; (80002d8 <ADC_Init+0x88>)
 8000256:	4b20      	ldr	r3, [pc, #128]	; (80002d8 <ADC_Init+0x88>)
 8000258:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800025a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800025e:	6453      	str	r3, [r2, #68]	; 0x44
	RCC->AHB1ENR |= (1<<0);  // enable GPIOA clock
 8000260:	4a1d      	ldr	r2, [pc, #116]	; (80002d8 <ADC_Init+0x88>)
 8000262:	4b1d      	ldr	r3, [pc, #116]	; (80002d8 <ADC_Init+0x88>)
 8000264:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000266:	f043 0301 	orr.w	r3, r3, #1
 800026a:	6313      	str	r3, [r2, #48]	; 0x30

//2. Set Resolution in the Control Register 1 (CR1)
	ADC1->CR1 &= ~(1<<24);   // 12 bit RES
 800026c:	4a1b      	ldr	r2, [pc, #108]	; (80002dc <ADC_Init+0x8c>)
 800026e:	4b1b      	ldr	r3, [pc, #108]	; (80002dc <ADC_Init+0x8c>)
 8000270:	685b      	ldr	r3, [r3, #4]
 8000272:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8000276:	6053      	str	r3, [r2, #4]

//3. Set the Continuous Conversion, enable DMA and Data Alignment in Control Reg 2 (CR2)
    ADC1->CR2 |= (1<<1);     // enable continuous conversion mode
 8000278:	4a18      	ldr	r2, [pc, #96]	; (80002dc <ADC_Init+0x8c>)
 800027a:	4b18      	ldr	r3, [pc, #96]	; (80002dc <ADC_Init+0x8c>)
 800027c:	689b      	ldr	r3, [r3, #8]
 800027e:	f043 0302 	orr.w	r3, r3, #2
 8000282:	6093      	str	r3, [r2, #8]
   // ADC1->CR2 |= (1<<10);    // EOC after each conversion
	ADC1->CR2 &= ~(1<<11);   // Data Alignment RIGHT
 8000284:	4a15      	ldr	r2, [pc, #84]	; (80002dc <ADC_Init+0x8c>)
 8000286:	4b15      	ldr	r3, [pc, #84]	; (80002dc <ADC_Init+0x8c>)
 8000288:	689b      	ldr	r3, [r3, #8]
 800028a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800028e:	6093      	str	r3, [r2, #8]
	ADC1->CR2 |= (1<<8);  //DMA mode enabled
 8000290:	4a12      	ldr	r2, [pc, #72]	; (80002dc <ADC_Init+0x8c>)
 8000292:	4b12      	ldr	r3, [pc, #72]	; (80002dc <ADC_Init+0x8c>)
 8000294:	689b      	ldr	r3, [r3, #8]
 8000296:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800029a:	6093      	str	r3, [r2, #8]
	ADC1->CR2 |= (1<<9);  // DMA enable continuous request
 800029c:	4a0f      	ldr	r2, [pc, #60]	; (80002dc <ADC_Init+0x8c>)
 800029e:	4b0f      	ldr	r3, [pc, #60]	; (80002dc <ADC_Init+0x8c>)
 80002a0:	689b      	ldr	r3, [r3, #8]
 80002a2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80002a6:	6093      	str	r3, [r2, #8]

//4. Set the Sampling Time for the channels
	//ADC1->SMPR2 &= ~(1<<3);  // Sampling time of 3 cycles for channel 1

//5. Set the Regular channel sequence length in ADC_SQR1
	ADC1->SQR1 &= ~(15<<20);   // SQR1_L =0 for 1 conversions
 80002a8:	4a0c      	ldr	r2, [pc, #48]	; (80002dc <ADC_Init+0x8c>)
 80002aa:	4b0c      	ldr	r3, [pc, #48]	; (80002dc <ADC_Init+0x8c>)
 80002ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80002ae:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 80002b2:	62d3      	str	r3, [r2, #44]	; 0x2c

	// Set Channel Sequence
	ADC1->SQR3 |= (1<<0);  // SEQ1 for Channel 1
 80002b4:	4a09      	ldr	r2, [pc, #36]	; (80002dc <ADC_Init+0x8c>)
 80002b6:	4b09      	ldr	r3, [pc, #36]	; (80002dc <ADC_Init+0x8c>)
 80002b8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80002ba:	f043 0301 	orr.w	r3, r3, #1
 80002be:	6353      	str	r3, [r2, #52]	; 0x34

//7. Set the Respective GPIO PINs in the Analog Mode
	GPIOA->MODER |= (3<<2);  // analog mode for PA 1 (channel 1)
 80002c0:	4a07      	ldr	r2, [pc, #28]	; (80002e0 <ADC_Init+0x90>)
 80002c2:	4b07      	ldr	r3, [pc, #28]	; (80002e0 <ADC_Init+0x90>)
 80002c4:	681b      	ldr	r3, [r3, #0]
 80002c6:	f043 030c 	orr.w	r3, r3, #12
 80002ca:	6013      	str	r3, [r2, #0]

}
 80002cc:	bf00      	nop
 80002ce:	46bd      	mov	sp, r7
 80002d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80002d4:	4770      	bx	lr
 80002d6:	bf00      	nop
 80002d8:	40023800 	.word	0x40023800
 80002dc:	40012000 	.word	0x40012000
 80002e0:	40020000 	.word	0x40020000

080002e4 <ADC_Enable>:


void ADC_Enable (void)
{
 80002e4:	b480      	push	{r7}
 80002e6:	b083      	sub	sp, #12
 80002e8:	af00      	add	r7, sp, #0
	/************** STEPS TO FOLLOW *****************
	1. Enable the ADC by setting ADON bit in CR2
	2. Wait for ADC to stabilize (approx 10us)
	************************************************/
	ADC1->CR2 |= 1<<0;   // ADON =1 enable ADC1
 80002ea:	4a0a      	ldr	r2, [pc, #40]	; (8000314 <ADC_Enable+0x30>)
 80002ec:	4b09      	ldr	r3, [pc, #36]	; (8000314 <ADC_Enable+0x30>)
 80002ee:	689b      	ldr	r3, [r3, #8]
 80002f0:	f043 0301 	orr.w	r3, r3, #1
 80002f4:	6093      	str	r3, [r2, #8]
	uint32_t delay = 10000;
 80002f6:	f242 7310 	movw	r3, #10000	; 0x2710
 80002fa:	607b      	str	r3, [r7, #4]
	while (delay--);
 80002fc:	bf00      	nop
 80002fe:	687b      	ldr	r3, [r7, #4]
 8000300:	1e5a      	subs	r2, r3, #1
 8000302:	607a      	str	r2, [r7, #4]
 8000304:	2b00      	cmp	r3, #0
 8000306:	d1fa      	bne.n	80002fe <ADC_Enable+0x1a>
}
 8000308:	bf00      	nop
 800030a:	370c      	adds	r7, #12
 800030c:	46bd      	mov	sp, r7
 800030e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000312:	4770      	bx	lr
 8000314:	40012000 	.word	0x40012000

08000318 <DMA_Config>:

void DMA_Config (void)
{
 8000318:	b480      	push	{r7}
 800031a:	af00      	add	r7, sp, #0
	3. Enable the DMA Stream

	Some peripherals don't need a start condition, like UART, So as soon as you enable the DMA, the transfer will begin
	While Peripherals like ADC needs the Start condition, so Start the ADC later in the program, to enable the transfer
	************************************************/
	DMA2_Stream0->PAR = (uint32_t)&ADC1->DR; // source
 800031c:	4b09      	ldr	r3, [pc, #36]	; (8000344 <DMA_Config+0x2c>)
 800031e:	4a0a      	ldr	r2, [pc, #40]	; (8000348 <DMA_Config+0x30>)
 8000320:	609a      	str	r2, [r3, #8]
	// Destination Address is memory address
	DMA2_Stream0->M0AR = (uint32_t)&ADC_VAL; // target
 8000322:	4b08      	ldr	r3, [pc, #32]	; (8000344 <DMA_Config+0x2c>)
 8000324:	4a09      	ldr	r2, [pc, #36]	; (800034c <DMA_Config+0x34>)
 8000326:	60da      	str	r2, [r3, #12]
	// Set the size of the transfer
	DMA2_Stream0->NDTR = 1; // size 1 == 8bit
 8000328:	4b06      	ldr	r3, [pc, #24]	; (8000344 <DMA_Config+0x2c>)
 800032a:	2201      	movs	r2, #1
 800032c:	605a      	str	r2, [r3, #4]
	// Enable the DMA Stream
	DMA2_Stream0->CR |= (1<<0);  // EN =1
 800032e:	4a05      	ldr	r2, [pc, #20]	; (8000344 <DMA_Config+0x2c>)
 8000330:	4b04      	ldr	r3, [pc, #16]	; (8000344 <DMA_Config+0x2c>)
 8000332:	681b      	ldr	r3, [r3, #0]
 8000334:	f043 0301 	orr.w	r3, r3, #1
 8000338:	6013      	str	r3, [r2, #0]
}
 800033a:	bf00      	nop
 800033c:	46bd      	mov	sp, r7
 800033e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000342:	4770      	bx	lr
 8000344:	40026410 	.word	0x40026410
 8000348:	4001204c 	.word	0x4001204c
 800034c:	2000001c 	.word	0x2000001c

08000350 <ADC_Start>:


void ADC_Start(void)
{
 8000350:	b480      	push	{r7}
 8000352:	af00      	add	r7, sp, #0
	/************** STEPS TO FOLLOW *****************
	1. Clear the Status register
	2. Start the Conversion by Setting the SWSTART bit in CR2
	*************************************************/
	ADC1->SR = 0;                      // Clear Status register
 8000354:	4b06      	ldr	r3, [pc, #24]	; (8000370 <ADC_Start+0x20>)
 8000356:	2200      	movs	r2, #0
 8000358:	601a      	str	r2, [r3, #0]
	ADC1->CR2 |= (1<<30);                // Start conversion for regular channel
 800035a:	4a05      	ldr	r2, [pc, #20]	; (8000370 <ADC_Start+0x20>)
 800035c:	4b04      	ldr	r3, [pc, #16]	; (8000370 <ADC_Start+0x20>)
 800035e:	689b      	ldr	r3, [r3, #8]
 8000360:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000364:	6093      	str	r3, [r2, #8]
}
 8000366:	bf00      	nop
 8000368:	46bd      	mov	sp, r7
 800036a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800036e:	4770      	bx	lr
 8000370:	40012000 	.word	0x40012000

08000374 <DMA_Init>:

void DMA_Init (void)
{
 8000374:	b480      	push	{r7}
 8000376:	af00      	add	r7, sp, #0
	5. Set the Data Size
	6. Select the channel for the Stream
	************************************************/

	// 1. DMA2 clock enable
	RCC -> AHB1ENR |= (1<<22);
 8000378:	4a14      	ldr	r2, [pc, #80]	; (80003cc <DMA_Init+0x58>)
 800037a:	4b14      	ldr	r3, [pc, #80]	; (80003cc <DMA_Init+0x58>)
 800037c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800037e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8000382:	6313      	str	r3, [r2, #48]	; 0x30

	// 2. Set the Data Direction
	DMA2_Stream0 -> CR &= ~(3<<10); // 00: Peripheral-to-memory
 8000384:	4a12      	ldr	r2, [pc, #72]	; (80003d0 <DMA_Init+0x5c>)
 8000386:	4b12      	ldr	r3, [pc, #72]	; (80003d0 <DMA_Init+0x5c>)
 8000388:	681b      	ldr	r3, [r3, #0]
 800038a:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800038e:	6013      	str	r3, [r2, #0]

	// 2. Enable the circular mode (CIRC)
	DMA2_Stream0 -> CR |= (1<<8);
 8000390:	4a0f      	ldr	r2, [pc, #60]	; (80003d0 <DMA_Init+0x5c>)
 8000392:	4b0f      	ldr	r3, [pc, #60]	; (80003d0 <DMA_Init+0x5c>)
 8000394:	681b      	ldr	r3, [r3, #0]
 8000396:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800039a:	6013      	str	r3, [r2, #0]

	// 3. Enable the Memory Increment (MINC)
	//DMA2_Stream0 -> CR |= (1<<10); //MINC:1

	// 4. Set the Peripheral data size (PSIZE)
	DMA2_Stream0 -> CR |= (1<<11); // PSIZE = 01,
 800039c:	4a0c      	ldr	r2, [pc, #48]	; (80003d0 <DMA_Init+0x5c>)
 800039e:	4b0c      	ldr	r3, [pc, #48]	; (80003d0 <DMA_Init+0x5c>)
 80003a0:	681b      	ldr	r3, [r3, #0]
 80003a2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80003a6:	6013      	str	r3, [r2, #0]

	// 5. Set the Memory data size (MSIZE)
	DMA2_Stream0 -> CR |= (1<<13); // MSIZE = 01, 16 bit data
 80003a8:	4a09      	ldr	r2, [pc, #36]	; (80003d0 <DMA_Init+0x5c>)
 80003aa:	4b09      	ldr	r3, [pc, #36]	; (80003d0 <DMA_Init+0x5c>)
 80003ac:	681b      	ldr	r3, [r3, #0]
 80003ae:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80003b2:	6013      	str	r3, [r2, #0]

	// 6. Select channel for the stream
	DMA2_Stream0->CR &= ~(7<<25);  // Channel 0 selected
 80003b4:	4a06      	ldr	r2, [pc, #24]	; (80003d0 <DMA_Init+0x5c>)
 80003b6:	4b06      	ldr	r3, [pc, #24]	; (80003d0 <DMA_Init+0x5c>)
 80003b8:	681b      	ldr	r3, [r3, #0]
 80003ba:	f023 6360 	bic.w	r3, r3, #234881024	; 0xe000000
 80003be:	6013      	str	r3, [r2, #0]

}
 80003c0:	bf00      	nop
 80003c2:	46bd      	mov	sp, r7
 80003c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80003c8:	4770      	bx	lr
 80003ca:	bf00      	nop
 80003cc:	40023800 	.word	0x40023800
 80003d0:	40026410 	.word	0x40026410

080003d4 <mapping>:


uint32_t mapping(uint32_t au32_IN, uint32_t au32_INmin, uint32_t au32_INmax, uint32_t au32_OUTmin, uint32_t au32_OUTmax)
{
 80003d4:	b480      	push	{r7}
 80003d6:	b085      	sub	sp, #20
 80003d8:	af00      	add	r7, sp, #0
 80003da:	60f8      	str	r0, [r7, #12]
 80003dc:	60b9      	str	r1, [r7, #8]
 80003de:	607a      	str	r2, [r7, #4]
 80003e0:	603b      	str	r3, [r7, #0]
    return ((((au32_IN - au32_INmin)*(au32_OUTmax - au32_OUTmin))/(au32_INmax - au32_INmin)) + au32_OUTmin);
 80003e2:	68fa      	ldr	r2, [r7, #12]
 80003e4:	68bb      	ldr	r3, [r7, #8]
 80003e6:	1ad3      	subs	r3, r2, r3
 80003e8:	69b9      	ldr	r1, [r7, #24]
 80003ea:	683a      	ldr	r2, [r7, #0]
 80003ec:	1a8a      	subs	r2, r1, r2
 80003ee:	fb02 f203 	mul.w	r2, r2, r3
 80003f2:	6879      	ldr	r1, [r7, #4]
 80003f4:	68bb      	ldr	r3, [r7, #8]
 80003f6:	1acb      	subs	r3, r1, r3
 80003f8:	fbb2 f2f3 	udiv	r2, r2, r3
 80003fc:	683b      	ldr	r3, [r7, #0]
 80003fe:	4413      	add	r3, r2
}
 8000400:	4618      	mov	r0, r3
 8000402:	3714      	adds	r7, #20
 8000404:	46bd      	mov	sp, r7
 8000406:	f85d 7b04 	ldr.w	r7, [sp], #4
 800040a:	4770      	bx	lr

0800040c <TIM2_Init>:

}


void TIM2_Init(void)
{
 800040c:	b480      	push	{r7}
 800040e:	af00      	add	r7, sp, #0
	// 1. Set clock
	RCC -> APB1ENR |= (1<<0); // enable tim2 clock (1<<0); macro RCC_APB1ENR_TIM2EN
 8000410:	4a2b      	ldr	r2, [pc, #172]	; (80004c0 <TIM2_Init+0xb4>)
 8000412:	4b2b      	ldr	r3, [pc, #172]	; (80004c0 <TIM2_Init+0xb4>)
 8000414:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000416:	f043 0301 	orr.w	r3, r3, #1
 800041a:	6413      	str	r3, [r2, #64]	; 0x40

	// 2. Configure the output pin:

    /* a) Select the output mode by writing CCS bits in CCMRx register */
	TIM2 ->CCMR1 |= (1<<3); // OC1PE
 800041c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000420:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000424:	699b      	ldr	r3, [r3, #24]
 8000426:	f043 0308 	orr.w	r3, r3, #8
 800042a:	6193      	str	r3, [r2, #24]

	// 3. Select the PWM mode PWM1 o by writing OCxM bits in CCMRx register
	TIM2 -> CCMR1 |= (6<<4);//  Set OC1M: Output PWM mode 1 Analog Pin A0
 800042c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000430:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000434:	699b      	ldr	r3, [r3, #24]
 8000436:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 800043a:	6193      	str	r3, [r2, #24]

/*	For example, If I want to give a pulse width of 1 ms i.e. (1*1000/20) = 50%,
    I will write 50 instead of X in CCR1 register.
    For 2 ms, It will be 100%, and for 1.5 ms, It will be 75% and so on*/

	TIM2->PSC = 319;
 800043c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000440:	f240 123f 	movw	r2, #319	; 0x13f
 8000444:	629a      	str	r2, [r3, #40]	; 0x28
	TIM2->ARR = 999;
 8000446:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800044a:	f240 32e7 	movw	r2, #999	; 0x3e7
 800044e:	62da      	str	r2, [r3, #44]	; 0x2c
	//TIM2 -> CCR1 = 998; // duty ccr1 / arr *100 %

	//5. Set the preload bit in CCMRx register and the ARPE bit in the CR1 register

	//ARPE: Auto-reload preload enable
	TIM2 -> CR1 |= (1<<7);//ARPE
 8000450:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000454:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000458:	681b      	ldr	r3, [r3, #0]
 800045a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800045e:	6013      	str	r3, [r2, #0]
	// Center-aligned mode 1 off
	//TIM2 -> CR1 |= (1<<5);

	//6. Enable the capture compare

	TIM2 -> CCER |= (1<<0); // 1: On - OC1 signal is output on the corresponding output pin
 8000460:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000464:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000468:	6a1b      	ldr	r3, [r3, #32]
 800046a:	f043 0301 	orr.w	r3, r3, #1
 800046e:	6213      	str	r3, [r2, #32]
	TIM2 -> EGR |= (1<<0); //Re-initialize the counter and generates an update of the registers
 8000470:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000474:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000478:	695b      	ldr	r3, [r3, #20]
 800047a:	f043 0301 	orr.w	r3, r3, #1
 800047e:	6153      	str	r3, [r2, #20]

	//7. Enable the counter.

	TIM2->CR1 |= TIM_CR1_CEN;
 8000480:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000484:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000488:	681b      	ldr	r3, [r3, #0]
 800048a:	f043 0301 	orr.w	r3, r3, #1
 800048e:	6013      	str	r3, [r2, #0]

	// Config Pin
	GPIOA -> MODER |= (2<<0); // PA0 10: Alternate function mode PIN A1
 8000490:	4a0c      	ldr	r2, [pc, #48]	; (80004c4 <TIM2_Init+0xb8>)
 8000492:	4b0c      	ldr	r3, [pc, #48]	; (80004c4 <TIM2_Init+0xb8>)
 8000494:	681b      	ldr	r3, [r3, #0]
 8000496:	f043 0302 	orr.w	r3, r3, #2
 800049a:	6013      	str	r3, [r2, #0]
	GPIOA -> OTYPER &=~(1<<0);// 0: Output push-pull (reset state)
 800049c:	4a09      	ldr	r2, [pc, #36]	; (80004c4 <TIM2_Init+0xb8>)
 800049e:	4b09      	ldr	r3, [pc, #36]	; (80004c4 <TIM2_Init+0xb8>)
 80004a0:	685b      	ldr	r3, [r3, #4]
 80004a2:	f023 0301 	bic.w	r3, r3, #1
 80004a6:	6053      	str	r3, [r2, #4]

	//!!!!!!!!!!!!
	// GPIO alternate function: GPIOA ->  AFR[1] Px8 - Px15, AFR[0] Px0 - Px7

	GPIOA ->AFR[0] |= (1<<0); // Set AF1, TIM2
 80004a8:	4a06      	ldr	r2, [pc, #24]	; (80004c4 <TIM2_Init+0xb8>)
 80004aa:	4b06      	ldr	r3, [pc, #24]	; (80004c4 <TIM2_Init+0xb8>)
 80004ac:	6a1b      	ldr	r3, [r3, #32]
 80004ae:	f043 0301 	orr.w	r3, r3, #1
 80004b2:	6213      	str	r3, [r2, #32]


}
 80004b4:	bf00      	nop
 80004b6:	46bd      	mov	sp, r7
 80004b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80004bc:	4770      	bx	lr
 80004be:	bf00      	nop
 80004c0:	40023800 	.word	0x40023800
 80004c4:	40020000 	.word	0x40020000

080004c8 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 80004c8:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000500 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80004cc:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80004ce:	e003      	b.n	80004d8 <LoopCopyDataInit>

080004d0 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80004d0:	4b0c      	ldr	r3, [pc, #48]	; (8000504 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80004d2:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80004d4:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80004d6:	3104      	adds	r1, #4

080004d8 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80004d8:	480b      	ldr	r0, [pc, #44]	; (8000508 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80004da:	4b0c      	ldr	r3, [pc, #48]	; (800050c <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80004dc:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80004de:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80004e0:	d3f6      	bcc.n	80004d0 <CopyDataInit>
  ldr  r2, =_sbss
 80004e2:	4a0b      	ldr	r2, [pc, #44]	; (8000510 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80004e4:	e002      	b.n	80004ec <LoopFillZerobss>

080004e6 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80004e6:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80004e8:	f842 3b04 	str.w	r3, [r2], #4

080004ec <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80004ec:	4b09      	ldr	r3, [pc, #36]	; (8000514 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80004ee:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80004f0:	d3f9      	bcc.n	80004e6 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 80004f2:	f000 f813 	bl	800051c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80004f6:	f000 f847 	bl	8000588 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80004fa:	f7ff fe6d 	bl	80001d8 <main>
  bx  lr    
 80004fe:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 8000500:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8000504:	080005f0 	.word	0x080005f0
  ldr  r0, =_sdata
 8000508:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800050c:	20000000 	.word	0x20000000
  ldr  r2, =_sbss
 8000510:	20000000 	.word	0x20000000
  ldr  r3, = _ebss
 8000514:	20000024 	.word	0x20000024

08000518 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000518:	e7fe      	b.n	8000518 <ADC_IRQHandler>
	...

0800051c <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800051c:	b480      	push	{r7}
 800051e:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000520:	4a16      	ldr	r2, [pc, #88]	; (800057c <SystemInit+0x60>)
 8000522:	4b16      	ldr	r3, [pc, #88]	; (800057c <SystemInit+0x60>)
 8000524:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8000528:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800052c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000530:	4a13      	ldr	r2, [pc, #76]	; (8000580 <SystemInit+0x64>)
 8000532:	4b13      	ldr	r3, [pc, #76]	; (8000580 <SystemInit+0x64>)
 8000534:	681b      	ldr	r3, [r3, #0]
 8000536:	f043 0301 	orr.w	r3, r3, #1
 800053a:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800053c:	4b10      	ldr	r3, [pc, #64]	; (8000580 <SystemInit+0x64>)
 800053e:	2200      	movs	r2, #0
 8000540:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000542:	4a0f      	ldr	r2, [pc, #60]	; (8000580 <SystemInit+0x64>)
 8000544:	4b0e      	ldr	r3, [pc, #56]	; (8000580 <SystemInit+0x64>)
 8000546:	681b      	ldr	r3, [r3, #0]
 8000548:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 800054c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000550:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000552:	4b0b      	ldr	r3, [pc, #44]	; (8000580 <SystemInit+0x64>)
 8000554:	4a0b      	ldr	r2, [pc, #44]	; (8000584 <SystemInit+0x68>)
 8000556:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000558:	4a09      	ldr	r2, [pc, #36]	; (8000580 <SystemInit+0x64>)
 800055a:	4b09      	ldr	r3, [pc, #36]	; (8000580 <SystemInit+0x64>)
 800055c:	681b      	ldr	r3, [r3, #0]
 800055e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000562:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000564:	4b06      	ldr	r3, [pc, #24]	; (8000580 <SystemInit+0x64>)
 8000566:	2200      	movs	r2, #0
 8000568:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800056a:	4b04      	ldr	r3, [pc, #16]	; (800057c <SystemInit+0x60>)
 800056c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000570:	609a      	str	r2, [r3, #8]
#endif
}
 8000572:	bf00      	nop
 8000574:	46bd      	mov	sp, r7
 8000576:	f85d 7b04 	ldr.w	r7, [sp], #4
 800057a:	4770      	bx	lr
 800057c:	e000ed00 	.word	0xe000ed00
 8000580:	40023800 	.word	0x40023800
 8000584:	24003010 	.word	0x24003010

08000588 <__libc_init_array>:
 8000588:	b570      	push	{r4, r5, r6, lr}
 800058a:	4e0d      	ldr	r6, [pc, #52]	; (80005c0 <__libc_init_array+0x38>)
 800058c:	4c0d      	ldr	r4, [pc, #52]	; (80005c4 <__libc_init_array+0x3c>)
 800058e:	1ba4      	subs	r4, r4, r6
 8000590:	10a4      	asrs	r4, r4, #2
 8000592:	2500      	movs	r5, #0
 8000594:	42a5      	cmp	r5, r4
 8000596:	d109      	bne.n	80005ac <__libc_init_array+0x24>
 8000598:	4e0b      	ldr	r6, [pc, #44]	; (80005c8 <__libc_init_array+0x40>)
 800059a:	4c0c      	ldr	r4, [pc, #48]	; (80005cc <__libc_init_array+0x44>)
 800059c:	f000 f818 	bl	80005d0 <_init>
 80005a0:	1ba4      	subs	r4, r4, r6
 80005a2:	10a4      	asrs	r4, r4, #2
 80005a4:	2500      	movs	r5, #0
 80005a6:	42a5      	cmp	r5, r4
 80005a8:	d105      	bne.n	80005b6 <__libc_init_array+0x2e>
 80005aa:	bd70      	pop	{r4, r5, r6, pc}
 80005ac:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80005b0:	4798      	blx	r3
 80005b2:	3501      	adds	r5, #1
 80005b4:	e7ee      	b.n	8000594 <__libc_init_array+0xc>
 80005b6:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80005ba:	4798      	blx	r3
 80005bc:	3501      	adds	r5, #1
 80005be:	e7f2      	b.n	80005a6 <__libc_init_array+0x1e>
 80005c0:	080005e8 	.word	0x080005e8
 80005c4:	080005e8 	.word	0x080005e8
 80005c8:	080005e8 	.word	0x080005e8
 80005cc:	080005ec 	.word	0x080005ec

080005d0 <_init>:
 80005d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80005d2:	bf00      	nop
 80005d4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80005d6:	bc08      	pop	{r3}
 80005d8:	469e      	mov	lr, r3
 80005da:	4770      	bx	lr

080005dc <_fini>:
 80005dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80005de:	bf00      	nop
 80005e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80005e2:	bc08      	pop	{r3}
 80005e4:	469e      	mov	lr, r3
 80005e6:	4770      	bx	lr
