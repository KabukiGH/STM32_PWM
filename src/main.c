/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2022-02-27

The MIT License (MIT)
Copyright (c) 2019 STMicroelectronics

******************************************************************************
*/

/* Includes */
#include "stm32f4xx.h"

/* Private macro */
/* Private variables */
volatile uint16_t ADC_VAL = 0;
volatile uint16_t angle = 0;
uint16_t msTicks = 0;

/* Private function prototypes */
void ADC_Init (void);
void ADC_Enable (void);
void DMA_Config (void);
void ADC_Start(void);
void DMA_Init (void);
uint32_t mapping(uint32_t au32_IN, uint32_t au32_INmin, uint32_t au32_INmax, uint32_t au32_OUTmin, uint32_t au32_OUTmax);
void ADC_WaitForConv (void);
uint16_t ADC_GetVal (void);
void Delay_ms(uint16_t time_ms);
void TIM2_Init(void);




int main(void)
{

	ADC_Init ();
	ADC_Enable ();
	DMA_Init ();
	DMA_Config ();
	TIM2_Init();

	ADC_Start ();



	while (1)
	{

	//ADC_WaitForConv();
	//ADC_VAL = ADC_GetVal();

	// Map The ADC Result To Servo Pulse Width
	angle = mapping(ADC_VAL, 0, 4096, 25, 125);
	// Set PWM duty cycle
	TIM2 -> CCR1 = angle;
	//Delay_ms (100);


	/* Testing PWM range
	//TIM2 -> CCR1 = 50; // duty cycle is 1 ms, according to Real servo position -45 Deg
	TIM2 -> CCR1 = 25; // duty cycle is 0.5 ms, according to Real servo position -90 Deg
	Delay_ms (2000);
	TIM2 -> CCR1 = 75; //  duty cycle is 1.5 ms according to Real servo position 0 Deg
	Delay_ms (2000);
	//TIM2 -> CCR1 = 100; //  duty cycle is 2 ms  according to Real servo position +45 Deg
	TIM2 -> CCR1 = 125; // duty cycle is 2.5 ms, according to Real servo position +90 Deg
	Delay_ms (2000);
	*/

	int breakPtr = 0;

	} // end while
} // end main

/* Interrupts */
void SysTick_Handler(void)
{
msTicks++;
}


/* Private functions */

void ADC_Init (void)
{
	/************** STEPS TO FOLLOW *****************
	1. Enable ADC and GPIO clock
	2. Set resolution in the Control Register 1 (CR1)
	3. Set the Continuous Conversion, enable DMA and Data Alignment in Control Reg 2 (CR2)
	4. Set the Sampling Time for the channels in ADC_SMPRx
	5. Set the Regular channel sequence length in ADC_SQR1 and set Channel 1 in ADC_SQR3
	7. Set the Respective GPIO PINs in the Analog Mode
	************************************************/

//1. Enable ADC and GPIO clock
	RCC->APB2ENR |= (1<<8);  // enable ADC1 clock
	RCC->AHB1ENR |= (1<<0);  // enable GPIOA clock

//2. Set Resolution in the Control Register 1 (CR1)
	ADC1->CR1 &= ~(1<<24);   // 12 bit RES

//3. Set the Continuous Conversion, enable DMA and Data Alignment in Control Reg 2 (CR2)
    ADC1->CR2 |= (1<<1);     // enable continuous conversion mode
   // ADC1->CR2 |= (1<<10);    // EOC after each conversion
	ADC1->CR2 &= ~(1<<11);   // Data Alignment RIGHT
	ADC1->CR2 |= (1<<8);  //DMA mode enabled
	ADC1->CR2 |= (1<<9);  // DMA enable continuous request

//4. Set the Sampling Time for the channels
	//ADC1->SMPR2 &= ~(1<<3);  // Sampling time of 3 cycles for channel 1

//5. Set the Regular channel sequence length in ADC_SQR1
	ADC1->SQR1 &= ~(15<<20);   // SQR1_L =0 for 1 conversions

	// Set Channel Sequence
	ADC1->SQR3 |= (1<<0);  // SEQ1 for Channel 1

//7. Set the Respective GPIO PINs in the Analog Mode
	GPIOA->MODER |= (3<<2);  // analog mode for PA 1 (channel 1)

}


void ADC_Enable (void)
{
	/************** STEPS TO FOLLOW *****************
	1. Enable the ADC by setting ADON bit in CR2
	2. Wait for ADC to stabilize (approx 10us)
	************************************************/
	ADC1->CR2 |= 1<<0;   // ADON =1 enable ADC1
	uint32_t delay = 10000;
	while (delay--);
}

void DMA_Config (void)
{

	/************** STEPS TO FOLLOW *****************
	1. Set the Data Size in the CNDTR Register
	2. Set the Peripheral Address and the Memory Address
	3. Enable the DMA Stream

	Some peripherals don't need a start condition, like UART, So as soon as you enable the DMA, the transfer will begin
	While Peripherals like ADC needs the Start condition, so Start the ADC later in the program, to enable the transfer
	************************************************/
	DMA2_Stream0->PAR = (uint32_t)&ADC1->DR; // source
	// Destination Address is memory address
	DMA2_Stream0->M0AR = (uint32_t)&ADC_VAL; // target
	// Set the size of the transfer
	DMA2_Stream0->NDTR = 1; // size 1 == 8bit
	// Enable the DMA Stream
	DMA2_Stream0->CR |= (1<<0);  // EN =1
}


void ADC_Start(void)
{
	/************** STEPS TO FOLLOW *****************
	1. Clear the Status register
	2. Start the Conversion by Setting the SWSTART bit in CR2
	*************************************************/
	ADC1->SR = 0;                      // Clear Status register
	ADC1->CR2 |= (1<<30);                // Start conversion for regular channel
}

void DMA_Init (void)
{
	/************** STEPS TO FOLLOW *****************
	1. Enable DMA clock
	2. Set the DATA Direction
	3. Enable/Disable the Circular Mode
	4. Enable/Disable the Memory Increment and Peripheral Increment
	5. Set the Data Size
	6. Select the channel for the Stream
	************************************************/

	// 1. DMA2 clock enable
	RCC -> AHB1ENR |= (1<<22);

	// 2. Set the Data Direction
	DMA2_Stream0 -> CR &= ~(3<<10); // 00: Peripheral-to-memory

	// 2. Enable the circular mode (CIRC)
	DMA2_Stream0 -> CR |= (1<<8);

	// 3. Enable the Memory Increment (MINC)
	//DMA2_Stream0 -> CR |= (1<<10); //MINC:1

	// 4. Set the Peripheral data size (PSIZE)
	DMA2_Stream0 -> CR |= (1<<11); // PSIZE = 01,

	// 5. Set the Memory data size (MSIZE)
	DMA2_Stream0 -> CR |= (1<<13); // MSIZE = 01, 16 bit data

	// 6. Select channel for the stream
	DMA2_Stream0->CR &= ~(7<<25);  // Channel 0 selected

}


uint32_t mapping(uint32_t au32_IN, uint32_t au32_INmin, uint32_t au32_INmax, uint32_t au32_OUTmin, uint32_t au32_OUTmax)
{
    return ((((au32_IN - au32_INmin)*(au32_OUTmax - au32_OUTmin))/(au32_INmax - au32_INmin)) + au32_OUTmin);
}

void ADC_WaitForConv (void)
{
	/*************************************************
	EOC Flag will be set, once the conversion is finished
	*************************************************/
	while (!(ADC1->SR & (1<<1)));  // wait for EOC flag to set
}

uint16_t ADC_GetVal (void)
{
	return ADC1->DR;  // Read the Data Register
}


void Delay_ms(uint16_t time_ms)
{
	static int config_flag = 1;
	msTicks=0;

	if(config_flag)
	{
		SysTick_Config(SystemCoreClock/1000); // set interrupt period every 1ms
		config_flag = 0;
	}

	while(msTicks<time_ms);

}


void TIM2_Init(void)
{
	// 1. Set clock
	RCC -> APB1ENR |= (1<<0); // enable tim2 clock (1<<0); macro RCC_APB1ENR_TIM2EN

	// 2. Configure the output pin:

    /* a) Select the output mode by writing CCS bits in CCMRx register */
	TIM2 ->CCMR1 |= (1<<3); // OC1PE

	// 3. Select the PWM mode PWM1 o by writing OCxM bits in CCMRx register
	TIM2 -> CCMR1 |= (6<<4);//  Set OC1M: Output PWM mode 1 Analog Pin A0

	// 4. Program the period and the duty cycle respectively in ARR and CCRx registers

	/*  Set freq 50Hz */

/*	For example, If I want to give a pulse width of 1 ms i.e. (1*1000/20) = 50%,
    I will write 50 instead of X in CCR1 register.
    For 2 ms, It will be 100%, and for 1.5 ms, It will be 75% and so on*/

	TIM2->PSC = 319;
	TIM2->ARR = 999;
	//TIM2 -> CCR1 = 998; // duty ccr1 / arr *100 %

	//5. Set the preload bit in CCMRx register and the ARPE bit in the CR1 register

	//ARPE: Auto-reload preload enable
	TIM2 -> CR1 |= (1<<7);//ARPE

	//6. Select the counting mode: edge-aligned mode: the counter must be configured up-counting or downcounting

	// Center-aligned mode 1 off
	//TIM2 -> CR1 |= (1<<5);

	//6. Enable the capture compare

	TIM2 -> CCER |= (1<<0); // 1: On - OC1 signal is output on the corresponding output pin
	TIM2 -> EGR |= (1<<0); //Re-initialize the counter and generates an update of the registers

	//7. Enable the counter.

	TIM2->CR1 |= TIM_CR1_CEN;

	// Config Pin
	GPIOA -> MODER |= (2<<0); // PA0 10: Alternate function mode PIN A1
	GPIOA -> OTYPER &=~(1<<0);// 0: Output push-pull (reset state)

	//!!!!!!!!!!!!
	// GPIO alternate function: GPIOA ->  AFR[1] Px8 - Px15, AFR[0] Px0 - Px7

	GPIOA ->AFR[0] |= (1<<0); // Set AF1, TIM2


}
