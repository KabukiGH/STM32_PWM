/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2022-02-27

The MIT License (MIT)
Copyright (c) 2019 STMicroelectronics

******************************************************************************
*/

/* Includes */
#include "stm32f4xx.h"

/* Private macro */
/* Private variables */
volatile uint16_t ADC_VAL = 0;
uint16_t angle = 0;
/* Private function prototypes */
void ADC_Init (void);
void ADC_Enable (void);
void DMA_Config (void);
void ADC_Start(void);
void DMA_Init (void);
uint32_t mapping(uint32_t au32_IN, uint32_t au32_INmin, uint32_t au32_INmax, uint32_t au32_OUTmin, uint32_t au32_OUTmax);


void ADC_WaitForConv (void)
{
	/*************************************************
	EOC Flag will be set, once the conversion is finished
	*************************************************/
	while (!(ADC1->SR & (1<<1)));  // wait for EOC flag to set
}

uint16_t ADC_GetVal (void)
{
	return ADC1->DR;  // Read the Data Register
}

int main(void)
{

	ADC_Init ();
	ADC_Enable ();
	//DMA_Init ();

	//DMA_Config ();
	ADC_Start ();

	while (1)
	{

	ADC_VAL = ADC_GetVal();
	ADC_WaitForConv();
	// Map The ADC Result To Servo Pulse Width
	angle = mapping(ADC_VAL, 0, 4096, 0, 180);

	//Delay_ms (1000);
	}
}


/* Private functions */

void ADC_Init (void)
{
	/************** STEPS TO FOLLOW *****************
	1. Enable ADC and GPIO clock
	2. Set resolution in the Control Register 1 (CR1)
	3. Set the Continuous Conversion, enable DMA and Data Alignment in Control Reg 2 (CR2)
	4. Set the Sampling Time for the channels in ADC_SMPRx
	5. Set the Regular channel sequence length in ADC_SQR1 and set Channel 1 in ADC_SQR3
	7. Set the Respective GPIO PINs in the Analog Mode
	************************************************/

//1. Enable ADC and GPIO clock
	RCC->APB2ENR |= (1<<8);  // enable ADC1 clock
	RCC->AHB1ENR |= (1<<0);  // enable GPIOA clock

//2. Set Resolution in the Control Register 1 (CR1)
	ADC1->CR1 &= ~(1<<24);   // 12 bit RES

//3. Set the Continuous Conversion, enable DMA and Data Alignment in Control Reg 2 (CR2)
    ADC1->CR2 |= (1<<1);     // enable continuous conversion mode
   // ADC1->CR2 |= (1<<10);    // EOC after each conversion
	ADC1->CR2 &= ~(1<<11);   // Data Alignment RIGHT
	//ADC1->CR2 |= (1<<8);  //DMA mode enabled
	//ADC1->CR2 |= (1<<9);  // DMA enable continuous request

//4. Set the Sampling Time for the channels
	//ADC1->SMPR2 &= ~(1<<3);  // Sampling time of 3 cycles for channel 1

//5. Set the Regular channel sequence length in ADC_SQR1
	ADC1->SQR1 &= ~(15<<20);   // SQR1_L =0 for 1 conversions

	// Set Channel Sequence
	ADC1->SQR3 |= (1<<0);  // SEQ1 for Channel 1

//7. Set the Respective GPIO PINs in the Analog Mode
	GPIOA->MODER |= (3<<2);  // analog mode for PA 1 (channel 1) PIN A1

}


void ADC_Enable (void)
{
	/************** STEPS TO FOLLOW *****************
	1. Enable the ADC by setting ADON bit in CR2
	2. Wait for ADC to stabilize (approx 10us)
	************************************************/
	ADC1->CR2 |= 1<<0;   // ADON =1 enable ADC1
	uint32_t delay = 10000;
	while (delay--);
}

void DMA_Config (void)
{

	/************** STEPS TO FOLLOW *****************
	1. Set the Data Size in the CNDTR Register
	2. Set the Peripheral Address and the Memory Address
	3. Enable the DMA Stream

	Some peripherals don't need a start condition, like UART, So as soon as you enable the DMA, the transfer will begin
	While Peripherals like ADC needs the Start condition, so Start the ADC later in the program, to enable the transfer
	************************************************/
	DMA2_Stream0->PAR = (uint32_t)&ADC1->DR; // source
	// Destination Address is memory address
	DMA2_Stream0->M0AR = (uint32_t)ADC_VAL; // target
	// Set the size of the transfer
	DMA2_Stream0->NDTR = 1; // size 1 == 8bit
	// Enable the DMA Stream
	DMA2_Stream0->CR |= (1<<0);  // EN =1
}


void ADC_Start(void)
{
	/************** STEPS TO FOLLOW *****************
	1. Clear the Status register
	2. Start the Conversion by Setting the SWSTART bit in CR2
	*************************************************/
	ADC1->SR = 0;                      // Clear Status register
	ADC1->CR2 |= (1<<30);                // Start conversion for regular channel
}

void DMA_Init (void)
{
	/************** STEPS TO FOLLOW *****************
	1. Enable DMA clock
	2. Set the DATA Direction
	3. Enable/Disable the Circular Mode
	4. Enable/Disable the Memory Increment and Peripheral Increment
	5. Set the Data Size
	6. Select the channel for the Stream
	************************************************/

	// 1. DMA2 clock enable
	RCC -> AHB1ENR |= (1<<22);

	// 2. Set the Data Direction
	DMA2_Stream0 -> CR &= ~(3<<10); // 00: Peripheral-to-memory

	// 2. Enable the circular mode (CIRC)
	DMA2_Stream0 -> CR |= (1<<8);

	// 3. Enable the Memory Increment (MINC)
	//DMA2_Stream0 -> CR |= (1<<10); //MINC:1

	// 4. Set the Peripheral data size (PSIZE)
	DMA2_Stream0 -> CR |= (1<<11); // PSIZE = 01,

	// 5. Set the Memory data size (MSIZE)
	DMA2_Stream0 -> CR |= (1<<13); // MSIZE = 01, 16 bit data

	// 6. Select channel for the stream
	DMA2_Stream0->CR &= ~(7<<25);  // Channel 0 selected

}


uint32_t mapping(uint32_t au32_IN, uint32_t au32_INmin, uint32_t au32_INmax, uint32_t au32_OUTmin, uint32_t au32_OUTmax)
{
    return ((((au32_IN - au32_INmin)*(au32_OUTmax - au32_OUTmin))/(au32_INmax - au32_INmin)) + au32_OUTmin);
}
